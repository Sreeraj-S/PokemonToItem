{
  "version": 3,
  "sources": ["../../../lib/streams.ts"],
  "sourcesContent": ["/**\r\n * Streams\r\n * Pokemon Showdown - http://pokemonshowdown.com/\r\n *\r\n * The Node.js standard library's Streams are really hard to use. This\r\n * offers a better stream API.\r\n *\r\n * Documented in STREAMS.md.\r\n *\r\n * @license MIT\r\n */\r\n\r\nconst BUF_SIZE = 65536 * 4;\r\n\r\ntype BufferEncoding =\r\n\t'ascii' | 'utf8' | 'utf-8' | 'utf16le' | 'ucs2' | 'ucs-2' | 'base64' | 'latin1' | 'binary' | 'hex';\r\n\r\nexport class ReadStream {\r\n\tbuf: Buffer;\r\n\tbufStart: number;\r\n\tbufEnd: number;\r\n\tbufCapacity: number;\r\n\treadSize: number;\r\n\tatEOF: boolean;\r\n\terrorBuf: Error[] | null;\r\n\tencoding: BufferEncoding;\r\n\tisReadable: boolean;\r\n\tisWritable: boolean;\r\n\tnodeReadableStream: NodeJS.ReadableStream | null;\r\n\tnextPushResolver: (() => void) | null;\r\n\tnextPush: Promise<void>;\r\n\tawaitingPush: boolean;\r\n\r\n\tconstructor(optionsOrStreamLike: {[k: string]: any} | NodeJS.ReadableStream | string | Buffer = {}) {\r\n\t\tthis.buf = Buffer.allocUnsafe(BUF_SIZE);\r\n\t\tthis.bufStart = 0;\r\n\t\tthis.bufEnd = 0;\r\n\t\tthis.bufCapacity = BUF_SIZE;\r\n\t\tthis.readSize = 0;\r\n\t\tthis.atEOF = false;\r\n\t\tthis.errorBuf = null;\r\n\t\tthis.encoding = 'utf8';\r\n\t\tthis.isReadable = true;\r\n\t\tthis.isWritable = false;\r\n\t\tthis.nodeReadableStream = null;\r\n\t\tthis.nextPushResolver = null;\r\n\t\tthis.nextPush = new Promise(resolve => {\r\n\t\t\tthis.nextPushResolver = resolve;\r\n\t\t});\r\n\t\tthis.awaitingPush = false;\r\n\r\n\t\tlet options;\r\n\t\tif (typeof optionsOrStreamLike === 'string') {\r\n\t\t\toptions = {buffer: optionsOrStreamLike};\r\n\t\t} else if (optionsOrStreamLike instanceof Buffer) {\r\n\t\t\toptions = {buffer: optionsOrStreamLike};\r\n\t\t} else if (typeof (optionsOrStreamLike as any)._readableState === 'object') {\r\n\t\t\toptions = {nodeStream: optionsOrStreamLike as NodeJS.ReadableStream};\r\n\t\t} else {\r\n\t\t\toptions = optionsOrStreamLike;\r\n\t\t}\r\n\t\tif (options.nodeStream) {\r\n\t\t\tconst nodeStream: NodeJS.ReadableStream = options.nodeStream;\r\n\t\t\tthis.nodeReadableStream = nodeStream;\r\n\t\t\tnodeStream.on('data', data => {\r\n\t\t\t\tthis.push(data);\r\n\t\t\t});\r\n\t\t\tnodeStream.on('end', () => {\r\n\t\t\t\tthis.pushEnd();\r\n\t\t\t});\r\n\r\n\t\t\toptions.read = function (this: ReadStream, unusedBytes: number) {\r\n\t\t\t\tthis.nodeReadableStream!.resume();\r\n\t\t\t};\r\n\r\n\t\t\toptions.pause = function (this: ReadStream, unusedBytes: number) {\r\n\t\t\t\tthis.nodeReadableStream!.pause();\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tif (options.read) this._read = options.read;\r\n\t\tif (options.pause) this._pause = options.pause;\r\n\t\tif (options.destroy) this._destroy = options.destroy;\r\n\t\tif (options.encoding) this.encoding = options.encoding;\r\n\t\tif (options.buffer !== undefined) {\r\n\t\t\tthis.push(options.buffer);\r\n\t\t\tthis.pushEnd();\r\n\t\t}\r\n\t}\r\n\r\n\tget bufSize() {\r\n\t\treturn this.bufEnd - this.bufStart;\r\n\t}\r\n\r\n\tmoveBuf() {\r\n\t\tif (this.bufStart !== this.bufEnd) {\r\n\t\t\tthis.buf.copy(this.buf, 0, this.bufStart, this.bufEnd);\r\n\t\t}\r\n\t\tthis.bufEnd -= this.bufStart;\r\n\t\tthis.bufStart = 0;\r\n\t}\r\n\r\n\texpandBuf(newCapacity = this.bufCapacity * 2) {\r\n\t\tconst newBuf = Buffer.allocUnsafe(newCapacity);\r\n\t\tthis.buf.copy(newBuf, 0, this.bufStart, this.bufEnd);\r\n\t\tthis.bufEnd -= this.bufStart;\r\n\t\tthis.bufStart = 0;\r\n\t\tthis.bufCapacity = newCapacity;\r\n\t\tthis.buf = newBuf;\r\n\t}\r\n\r\n\tensureCapacity(additionalCapacity: number) {\r\n\t\tif (this.bufEnd + additionalCapacity <= this.bufCapacity) return;\r\n\t\tconst capacity = this.bufEnd - this.bufStart + additionalCapacity;\r\n\t\tif (capacity <= this.bufCapacity) {\r\n\t\t\treturn this.moveBuf();\r\n\t\t}\r\n\t\tlet newCapacity = this.bufCapacity * 2;\r\n\t\twhile (newCapacity < capacity) newCapacity *= 2;\r\n\t\tthis.expandBuf(newCapacity);\r\n\t}\r\n\r\n\tpush(buf: Buffer | string, encoding: BufferEncoding = this.encoding) {\r\n\t\tlet size;\r\n\t\tif (this.atEOF) return;\r\n\t\tif (typeof buf === 'string') {\r\n\t\t\tsize = Buffer.byteLength(buf, encoding);\r\n\t\t\tthis.ensureCapacity(size);\r\n\t\t\tthis.buf.write(buf, this.bufEnd);\r\n\t\t} else {\r\n\t\t\tsize = buf.length;\r\n\t\t\tthis.ensureCapacity(size);\r\n\t\t\tbuf.copy(this.buf, this.bufEnd);\r\n\t\t}\r\n\t\tthis.bufEnd += size;\r\n\t\tif (this.bufSize > this.readSize && size * 2 < this.bufSize) this._pause();\r\n\t\tthis.resolvePush();\r\n\t}\r\n\r\n\tpushEnd() {\r\n\t\tthis.atEOF = true;\r\n\t\tthis.resolvePush();\r\n\t}\r\n\r\n\tpushError(err: Error, recoverable?: boolean) {\r\n\t\tif (!this.errorBuf) this.errorBuf = [];\r\n\t\tthis.errorBuf.push(err);\r\n\t\tif (!recoverable) this.atEOF = true;\r\n\t\tthis.resolvePush();\r\n\t}\r\n\r\n\treadError() {\r\n\t\tif (this.errorBuf) {\r\n\t\t\tconst err = this.errorBuf.shift()!;\r\n\t\t\tif (!this.errorBuf.length) this.errorBuf = null;\r\n\t\t\tthrow err;\r\n\t\t}\r\n\t}\r\n\r\n\tpeekError() {\r\n\t\tif (this.errorBuf) {\r\n\t\t\tthrow this.errorBuf[0];\r\n\t\t}\r\n\t}\r\n\r\n\tresolvePush() {\r\n\t\tif (!this.nextPushResolver) throw new Error(`Push after end of read stream`);\r\n\t\tthis.nextPushResolver();\r\n\t\tif (this.atEOF) {\r\n\t\t\tthis.nextPushResolver = null;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.nextPush = new Promise(resolve => {\r\n\t\t\tthis.nextPushResolver = resolve;\r\n\t\t});\r\n\t}\r\n\r\n\t_read(size = 0): void | Promise<void> {\r\n\t\tthrow new Error(`ReadStream needs to be subclassed and the _read function needs to be implemented.`);\r\n\t}\r\n\r\n\t_destroy(): void | Promise<void> {}\r\n\t_pause() {}\r\n\r\n\t/**\r\n\t * Reads until the internal buffer is non-empty. Does nothing if the\r\n\t * internal buffer is already non-empty.\r\n\t *\r\n\t * If `byteCount` is a number, instead read until the internal buffer\r\n\t * contains at least `byteCount` bytes.\r\n\t *\r\n\t * If `byteCount` is `true`, reads even if the internal buffer is\r\n\t * non-empty.\r\n\t */\r\n\tloadIntoBuffer(byteCount: number | null | true = null, readError?: boolean) {\r\n\t\tthis[readError ? 'readError' : 'peekError']();\r\n\t\tif (byteCount === 0) return;\r\n\t\tthis.readSize = Math.max(\r\n\t\t\tbyteCount === true ? this.bufSize + 1 : byteCount === null ? 1 : byteCount,\r\n\t\t\tthis.readSize\r\n\t\t);\r\n\t\tif (!this.errorBuf && !this.atEOF && this.bufSize < this.readSize) {\r\n\t\t\tlet bytes: number | null = this.readSize - this.bufSize;\r\n\t\t\tif (bytes === Infinity || byteCount === null || byteCount === true) bytes = null;\r\n\t\t\treturn this.doLoad(bytes, readError);\r\n\t\t}\r\n\t}\r\n\r\n\tasync doLoad(chunkSize?: number | null, readError?: boolean) {\r\n\t\twhile (!this.errorBuf && !this.atEOF && this.bufSize < this.readSize) {\r\n\t\t\tif (chunkSize) void this._read(chunkSize);\r\n\t\t\telse void this._read();\r\n\t\t\tawait this.nextPush;\r\n\t\t\tthis[readError ? 'readError' : 'peekError']();\r\n\t\t}\r\n\t}\r\n\r\n\tpeek(byteCount?: number | null, encoding?: BufferEncoding): string | null | Promise<string | null>;\r\n\tpeek(encoding: BufferEncoding): string | null | Promise<string | null>;\r\n\tpeek(byteCount: number | string | null = null, encoding: BufferEncoding = this.encoding) {\r\n\t\tif (typeof byteCount === 'string') {\r\n\t\t\tencoding = byteCount as BufferEncoding;\r\n\t\t\tbyteCount = null;\r\n\t\t}\r\n\t\tconst maybeLoad = this.loadIntoBuffer(byteCount);\r\n\t\tif (maybeLoad) return maybeLoad.then(() => this.peek(byteCount as number, encoding));\r\n\r\n\t\tif (!this.bufSize && byteCount !== 0) return null;\r\n\t\tif (byteCount === null) return this.buf.toString(encoding, this.bufStart, this.bufEnd);\r\n\t\tif (byteCount > this.bufSize) byteCount = this.bufSize;\r\n\t\treturn this.buf.toString(encoding, this.bufStart, this.bufStart + byteCount);\r\n\t}\r\n\r\n\tpeekBuffer(byteCount: number | null = null): Buffer | null | Promise<Buffer | null> {\r\n\t\tconst maybeLoad = this.loadIntoBuffer(byteCount);\r\n\t\tif (maybeLoad) return maybeLoad.then(() => this.peekBuffer(byteCount));\r\n\r\n\t\tif (!this.bufSize && byteCount !== 0) return null;\r\n\t\tif (byteCount === null) return this.buf.slice(this.bufStart, this.bufEnd);\r\n\t\tif (byteCount > this.bufSize) byteCount = this.bufSize;\r\n\t\treturn this.buf.slice(this.bufStart, this.bufStart + byteCount);\r\n\t}\r\n\r\n\tasync read(byteCount?: number | null, encoding?: BufferEncoding): Promise<string | null>;\r\n\tasync read(encoding: BufferEncoding): Promise<string | null>;\r\n\tasync read(byteCount: number | string | null = null, encoding: BufferEncoding = this.encoding) {\r\n\t\tif (typeof byteCount === 'string') {\r\n\t\t\tencoding = byteCount as BufferEncoding;\r\n\t\t\tbyteCount = null;\r\n\t\t}\r\n\t\tawait this.loadIntoBuffer(byteCount, true);\r\n\r\n\t\t// This MUST NOT be awaited: we MUST synchronously clear byteCount after peeking\r\n\t\t// if the buffer is written to after peek but before clearing the buffer, the write\r\n\t\t// will be lost forever\r\n\t\tconst out = this.peek(byteCount, encoding);\r\n\t\tif (out && typeof out !== 'string') {\r\n\t\t\tthrow new Error(\"Race condition; you must not read before a previous read has completed\");\r\n\t\t}\r\n\r\n\t\tif (byteCount === null || byteCount >= this.bufSize) {\r\n\t\t\tthis.bufStart = 0;\r\n\t\t\tthis.bufEnd = 0;\r\n\t\t\tthis.readSize = 0;\r\n\t\t} else {\r\n\t\t\tthis.bufStart += byteCount;\r\n\t\t\tthis.readSize -= byteCount;\r\n\t\t}\r\n\t\treturn out;\r\n\t}\r\n\r\n\tbyChunk(byteCount?: number | null) {\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-this-alias\r\n\t\tconst byteStream = this;\r\n\t\treturn new ObjectReadStream<string>({\r\n\t\t\tasync read(this: ObjectReadStream<string>) {\r\n\t\t\t\tconst next = await byteStream.read(byteCount);\r\n\t\t\t\tif (typeof next === 'string') this.push(next);\r\n\t\t\t\telse this.pushEnd();\r\n\t\t\t},\r\n\t\t});\r\n\t}\r\n\r\n\tbyLine() {\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-this-alias\r\n\t\tconst byteStream = this;\r\n\t\treturn new ObjectReadStream<string>({\r\n\t\t\tasync read(this: ObjectReadStream<string>) {\r\n\t\t\t\tconst next = await byteStream.readLine();\r\n\t\t\t\tif (typeof next === 'string') this.push(next);\r\n\t\t\t\telse this.pushEnd();\r\n\t\t\t},\r\n\t\t});\r\n\t}\r\n\r\n\tdelimitedBy(delimiter: string) {\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-this-alias\r\n\t\tconst byteStream = this;\r\n\t\treturn new ObjectReadStream<string>({\r\n\t\t\tasync read(this: ObjectReadStream<string>) {\r\n\t\t\t\tconst next = await byteStream.readDelimitedBy(delimiter);\r\n\t\t\t\tif (typeof next === 'string') this.push(next);\r\n\t\t\t\telse this.pushEnd();\r\n\t\t\t},\r\n\t\t});\r\n\t}\r\n\r\n\tasync readBuffer(byteCount: number | null = null) {\r\n\t\tawait this.loadIntoBuffer(byteCount, true);\r\n\r\n\t\t// This MUST NOT be awaited: we must synchronously clear the buffer after peeking\r\n\t\t// (see `read`)\r\n\t\tconst out = this.peekBuffer(byteCount);\r\n\t\tif (out && (out as Promise<unknown>).then) {\r\n\t\t\tthrow new Error(\"Race condition; you must not read before a previous read has completed\");\r\n\t\t}\r\n\r\n\t\tif (byteCount === null || byteCount >= this.bufSize) {\r\n\t\t\tthis.bufStart = 0;\r\n\t\t\tthis.bufEnd = 0;\r\n\t\t} else {\r\n\t\t\tthis.bufStart += byteCount;\r\n\t\t}\r\n\t\treturn out;\r\n\t}\r\n\r\n\tasync indexOf(symbol: string, encoding: BufferEncoding = this.encoding) {\r\n\t\tlet idx = this.buf.indexOf(symbol, this.bufStart, encoding);\r\n\t\twhile (!this.atEOF && (idx >= this.bufEnd || idx < 0)) {\r\n\t\t\tawait this.loadIntoBuffer(true);\r\n\t\t\tidx = this.buf.indexOf(symbol, this.bufStart, encoding);\r\n\t\t}\r\n\t\tif (idx >= this.bufEnd) return -1;\r\n\t\treturn idx - this.bufStart;\r\n\t}\r\n\r\n\tasync readAll(encoding: BufferEncoding = this.encoding) {\r\n\t\treturn (await this.read(Infinity, encoding)) || '';\r\n\t}\r\n\r\n\tpeekAll(encoding: BufferEncoding = this.encoding) {\r\n\t\treturn this.peek(Infinity, encoding);\r\n\t}\r\n\r\n\tasync readDelimitedBy(symbol: string, encoding: BufferEncoding = this.encoding) {\r\n\t\tif (this.atEOF && !this.bufSize) return null;\r\n\t\tconst idx = await this.indexOf(symbol, encoding);\r\n\t\tif (idx < 0) {\r\n\t\t\treturn this.readAll(encoding);\r\n\t\t} else {\r\n\t\t\tconst out = await this.read(idx, encoding);\r\n\t\t\tthis.bufStart += Buffer.byteLength(symbol, 'utf8');\r\n\t\t\treturn out;\r\n\t\t}\r\n\t}\r\n\r\n\tasync readLine(encoding: BufferEncoding = this.encoding) {\r\n\t\tif (!encoding) throw new Error(`readLine must have an encoding`);\r\n\t\tlet line = await this.readDelimitedBy('\\n', encoding);\r\n\t\tif (line?.endsWith('\\r')) line = line.slice(0, -1);\r\n\t\treturn line;\r\n\t}\r\n\r\n\tdestroy() {\r\n\t\tthis.atEOF = true;\r\n\t\tthis.bufStart = 0;\r\n\t\tthis.bufEnd = 0;\r\n\t\tif (this.nextPushResolver) this.resolvePush();\r\n\t\treturn this._destroy();\r\n\t}\r\n\r\n\tasync next(byteCount: number | null = null) {\r\n\t\tconst value = await this.read(byteCount);\r\n\t\treturn {value, done: value === null};\r\n\t}\r\n\r\n\tasync pipeTo(outStream: WriteStream, options: {noEnd?: boolean} = {}) {\r\n\t\tlet value, done;\r\n\t\twhile (({value, done} = await this.next(), !done)) {\r\n\t\t\tawait outStream.write(value!);\r\n\t\t}\r\n\t\tif (!options.noEnd) return outStream.writeEnd();\r\n\t}\r\n}\r\n\r\ninterface WriteStreamOptions {\r\n\tnodeStream?: NodeJS.WritableStream;\r\n\twrite?: (this: WriteStream, data: string | Buffer) => (Promise<undefined> | undefined);\r\n\twriteEnd?: (this: WriteStream) => Promise<any>;\r\n}\r\n\r\nexport class WriteStream {\r\n\tisReadable: boolean;\r\n\tisWritable: true;\r\n\tencoding: BufferEncoding;\r\n\tnodeWritableStream: NodeJS.WritableStream | null;\r\n\tdrainListeners: (() => void)[];\r\n\r\n\tconstructor(optionsOrStream: WriteStreamOptions | NodeJS.WritableStream = {}) {\r\n\t\tthis.isReadable = false;\r\n\t\tthis.isWritable = true;\r\n\t\tthis.encoding = 'utf8';\r\n\t\tthis.nodeWritableStream = null;\r\n\t\tthis.drainListeners = [];\r\n\r\n\t\tlet options: WriteStreamOptions = optionsOrStream as any;\r\n\t\tif ((options as any)._writableState) {\r\n\t\t\toptions = {nodeStream: optionsOrStream as NodeJS.WritableStream};\r\n\t\t}\r\n\t\tif (options.nodeStream) {\r\n\t\t\tconst nodeStream: NodeJS.WritableStream = options.nodeStream;\r\n\t\t\tthis.nodeWritableStream = nodeStream;\r\n\t\t\toptions.write = function (data: string | Buffer) {\r\n\t\t\t\tconst result = this.nodeWritableStream!.write(data);\r\n\t\t\t\tif (result !== false) return undefined;\r\n\t\t\t\tif (!this.drainListeners.length) {\r\n\t\t\t\t\tthis.nodeWritableStream!.once('drain', () => {\r\n\t\t\t\t\t\tfor (const listener of this.drainListeners) listener();\r\n\t\t\t\t\t\tthis.drainListeners = [];\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\treturn new Promise(resolve => {\r\n\t\t\t\t\t// `as () => void` is necessary because TypeScript thinks that it should be a function\r\n\t\t\t\t\t// that takes an undefined value as its only parameter: `(value: PromiseLike<undefined> | undefined) => void`\r\n\t\t\t\t\tthis.drainListeners.push(resolve as () => void);\r\n\t\t\t\t});\r\n\t\t\t};\r\n\t\t\t// Prior to Node v10.12.0, attempting to close STDOUT or STDERR will throw\r\n\t\t\tif (nodeStream !== process.stdout && nodeStream !== process.stderr) {\r\n\t\t\t\toptions.writeEnd = function () {\r\n\t\t\t\t\treturn new Promise<void>(resolve => {\r\n\t\t\t\t\t\tthis.nodeWritableStream!.end(() => resolve());\r\n\t\t\t\t\t});\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (options.write) this._write = options.write;\r\n\t\tif (options.writeEnd) this._writeEnd = options.writeEnd;\r\n\t}\r\n\r\n\twrite(chunk: Buffer | string): void | Promise<void> {\r\n\t\treturn this._write(chunk);\r\n\t}\r\n\r\n\twriteLine(chunk: string): void | Promise<void> {\r\n\t\tif (chunk === null) {\r\n\t\t\treturn this.writeEnd();\r\n\t\t}\r\n\t\treturn this.write(chunk + '\\n');\r\n\t}\r\n\r\n\t_write(chunk: Buffer | string): void | Promise<void> {\r\n\t\tthrow new Error(`WriteStream needs to be subclassed and the _write function needs to be implemented.`);\r\n\t}\r\n\r\n\t_writeEnd(): void | Promise<void> {}\r\n\r\n\tasync writeEnd(chunk?: string): Promise<void> {\r\n\t\tif (chunk) {\r\n\t\t\tawait this.write(chunk);\r\n\t\t}\r\n\t\treturn this._writeEnd();\r\n\t}\r\n}\r\n\r\nexport class ReadWriteStream extends ReadStream implements WriteStream {\r\n\tisReadable: true;\r\n\tisWritable: true;\r\n\tnodeWritableStream: NodeJS.WritableStream | null;\r\n\tdrainListeners: (() => void)[];\r\n\r\n\tconstructor(options: AnyObject = {}) {\r\n\t\tsuper(options);\r\n\t\tthis.isReadable = true;\r\n\t\tthis.isWritable = true;\r\n\t\tthis.nodeWritableStream = null;\r\n\t\tthis.drainListeners = [];\r\n\r\n\t\tif (options.nodeStream) {\r\n\t\t\tconst nodeStream: NodeJS.WritableStream = options.nodeStream;\r\n\t\t\tthis.nodeWritableStream = nodeStream;\r\n\t\t\toptions.write = function (data: string | Buffer) {\r\n\t\t\t\tconst result = this.nodeWritableStream.write(data);\r\n\t\t\t\tif (result !== false) return undefined;\r\n\t\t\t\tif (!this.drainListeners.length) {\r\n\t\t\t\t\tthis.nodeWritableStream.once('drain', () => {\r\n\t\t\t\t\t\tfor (const listener of this.drainListeners) listener();\r\n\t\t\t\t\t\tthis.drainListeners = [];\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\treturn new Promise(resolve => {\r\n\t\t\t\t\tthis.drainListeners.push(resolve);\r\n\t\t\t\t});\r\n\t\t\t};\r\n\t\t\t// Prior to Node v10.12.0, attempting to close STDOUT or STDERR will throw\r\n\t\t\tif (nodeStream !== process.stdout && nodeStream !== process.stderr) {\r\n\t\t\t\toptions.writeEnd = function () {\r\n\t\t\t\t\treturn new Promise<void>(resolve => {\r\n\t\t\t\t\t\tthis.nodeWritableStream.end(() => resolve());\r\n\t\t\t\t\t});\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (options.write) this._write = options.write;\r\n\t\tif (options.writeEnd) this._writeEnd = options.writeEnd;\r\n\t}\r\n\r\n\twrite(chunk: Buffer | string): Promise<void> | void {\r\n\t\treturn this._write(chunk);\r\n\t}\r\n\r\n\twriteLine(chunk: string): Promise<void> | void {\r\n\t\treturn this.write(chunk + '\\n');\r\n\t}\r\n\r\n\t_write(chunk: Buffer | string): Promise<void> | void {\r\n\t\tthrow new Error(`WriteStream needs to be subclassed and the _write function needs to be implemented.`);\r\n\t}\r\n\r\n\t/**\r\n\t * In a ReadWriteStream, `_read` does not need to be implemented,\r\n\t * because it's valid for the read stream buffer to be filled only by\r\n\t * `_write`.\r\n\t */\r\n\t_read(size?: number) {}\r\n\r\n\t_writeEnd(): void | Promise<void> {}\r\n\r\n\tasync writeEnd() {\r\n\t\treturn this._writeEnd();\r\n\t}\r\n}\r\n\r\ntype ObjectReadStreamOptions<T> = {\r\n\tbuffer?: T[],\r\n\tread?: (this: ObjectReadStream<T>) => void | Promise<void>,\r\n\tpause?: (this: ObjectReadStream<T>) => void | Promise<void>,\r\n\tdestroy?: (this: ObjectReadStream<T>) => void | Promise<void>,\r\n\tnodeStream?: undefined,\r\n} | {\r\n\tbuffer?: undefined,\r\n\tread?: undefined,\r\n\tpause?: undefined,\r\n\tdestroy?: undefined,\r\n\tnodeStream: NodeJS.ReadableStream,\r\n};\r\n\r\nexport class ObjectReadStream<T> {\r\n\tbuf: T[];\r\n\treadSize: number;\r\n\tatEOF: boolean;\r\n\terrorBuf: Error[] | null;\r\n\tisReadable: boolean;\r\n\tisWritable: boolean;\r\n\tnodeReadableStream: NodeJS.ReadableStream | null;\r\n\tnextPushResolver: (() => void) | null;\r\n\tnextPush: Promise<void>;\r\n\tawaitingPush: boolean;\r\n\r\n\tconstructor(optionsOrStreamLike: ObjectReadStreamOptions<T> | NodeJS.ReadableStream | T[] = {}) {\r\n\t\tthis.buf = [];\r\n\t\tthis.readSize = 0;\r\n\t\tthis.atEOF = false;\r\n\t\tthis.errorBuf = null;\r\n\t\tthis.isReadable = true;\r\n\t\tthis.isWritable = false;\r\n\t\tthis.nodeReadableStream = null;\r\n\t\tthis.nextPushResolver = null;\r\n\t\tthis.nextPush = new Promise(resolve => {\r\n\t\t\tthis.nextPushResolver = resolve;\r\n\t\t});\r\n\t\tthis.awaitingPush = false;\r\n\r\n\t\tlet options: ObjectReadStreamOptions<T>;\r\n\t\tif (Array.isArray(optionsOrStreamLike)) {\r\n\t\t\toptions = {buffer: optionsOrStreamLike};\r\n\t\t} else if (typeof (optionsOrStreamLike as any)._readableState === 'object') {\r\n\t\t\toptions = {nodeStream: optionsOrStreamLike as NodeJS.ReadableStream};\r\n\t\t} else {\r\n\t\t\toptions = optionsOrStreamLike as ObjectReadStreamOptions<T>;\r\n\t\t}\r\n\t\tif ((options as any).nodeStream) {\r\n\t\t\tconst nodeStream: NodeJS.ReadableStream = (options as any).nodeStream;\r\n\t\t\tthis.nodeReadableStream = nodeStream;\r\n\t\t\tnodeStream.on('data', data => {\r\n\t\t\t\tthis.push(data);\r\n\t\t\t});\r\n\t\t\tnodeStream.on('end', () => {\r\n\t\t\t\tthis.pushEnd();\r\n\t\t\t});\r\n\r\n\t\t\toptions = {\r\n\t\t\t\tread() {\r\n\t\t\t\t\tthis.nodeReadableStream!.resume();\r\n\t\t\t\t},\r\n\t\t\t\tpause() {\r\n\t\t\t\t\tthis.nodeReadableStream!.pause();\r\n\t\t\t\t},\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tif (options.read) this._read = options.read;\r\n\t\tif (options.pause) this._pause = options.pause;\r\n\t\tif (options.destroy) this._destroy = options.destroy;\r\n\t\tif (options.buffer !== undefined) {\r\n\t\t\tthis.buf = options.buffer.slice();\r\n\t\t\tthis.pushEnd();\r\n\t\t}\r\n\t}\r\n\r\n\tpush(elem: T) {\r\n\t\tif (this.atEOF) return;\r\n\t\tthis.buf.push(elem);\r\n\t\tif (this.buf.length > this.readSize && this.buf.length >= 16) void this._pause();\r\n\t\tthis.resolvePush();\r\n\t}\r\n\r\n\tpushEnd() {\r\n\t\tthis.atEOF = true;\r\n\t\tthis.resolvePush();\r\n\t}\r\n\r\n\tpushError(err: Error, recoverable?: boolean) {\r\n\t\tif (!this.errorBuf) this.errorBuf = [];\r\n\t\tthis.errorBuf.push(err);\r\n\t\tif (!recoverable) this.atEOF = true;\r\n\t\tthis.resolvePush();\r\n\t}\r\n\r\n\treadError() {\r\n\t\tif (this.errorBuf) {\r\n\t\t\tconst err = this.errorBuf.shift()!;\r\n\t\t\tif (!this.errorBuf.length) this.errorBuf = null;\r\n\t\t\tthrow err;\r\n\t\t}\r\n\t}\r\n\r\n\tpeekError() {\r\n\t\tif (this.errorBuf) {\r\n\t\t\tthrow this.errorBuf[0];\r\n\t\t}\r\n\t}\r\n\r\n\tresolvePush() {\r\n\t\tif (!this.nextPushResolver) throw new Error(`Push after end of read stream`);\r\n\t\tthis.nextPushResolver();\r\n\t\tif (this.atEOF) {\r\n\t\t\tthis.nextPushResolver = null;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.nextPush = new Promise(resolve => {\r\n\t\t\tthis.nextPushResolver = resolve;\r\n\t\t});\r\n\t}\r\n\r\n\t_read(size = 0): void | Promise<void> {\r\n\t\tthrow new Error(`ReadStream needs to be subclassed and the _read function needs to be implemented.`);\r\n\t}\r\n\r\n\t_destroy(): void | Promise<void> {}\r\n\t_pause(): void | Promise<void> {}\r\n\r\n\tasync loadIntoBuffer(count: number | true = 1, readError?: boolean) {\r\n\t\tthis[readError ? 'readError' : 'peekError']();\r\n\t\tif (count === true) count = this.buf.length + 1;\r\n\t\tif (this.buf.length >= count) return;\r\n\t\tthis.readSize = Math.max(count, this.readSize);\r\n\t\twhile (!this.errorBuf && !this.atEOF && this.buf.length < this.readSize) {\r\n\t\t\tconst readResult = this._read();\r\n\t\t\tif (readResult) {\r\n\t\t\t\tawait readResult;\r\n\t\t\t} else {\r\n\t\t\t\tawait this.nextPush;\r\n\t\t\t}\r\n\t\t\tthis[readError ? 'readError' : 'peekError']();\r\n\t\t}\r\n\t}\r\n\r\n\tasync peek() {\r\n\t\tif (this.buf.length) return this.buf[0];\r\n\t\tawait this.loadIntoBuffer();\r\n\t\treturn this.buf[0];\r\n\t}\r\n\r\n\tasync read() {\r\n\t\tif (this.buf.length) return this.buf.shift();\r\n\t\tawait this.loadIntoBuffer(1, true);\r\n\t\tif (!this.buf.length) return null;\r\n\t\treturn this.buf.shift()!;\r\n\t}\r\n\r\n\tasync peekArray(count: number | null = null) {\r\n\t\tawait this.loadIntoBuffer(count === null ? 1 : count);\r\n\t\treturn this.buf.slice(0, count === null ? Infinity : count);\r\n\t}\r\n\r\n\tasync readArray(count: number | null = null) {\r\n\t\tawait this.loadIntoBuffer(count === null ? 1 : count, true);\r\n\t\tconst out = this.buf.slice(0, count === null ? Infinity : count);\r\n\t\tthis.buf = this.buf.slice(out.length);\r\n\t\treturn out;\r\n\t}\r\n\r\n\tasync readAll() {\r\n\t\tawait this.loadIntoBuffer(Infinity, true);\r\n\t\tconst out = this.buf;\r\n\t\tthis.buf = [];\r\n\t\treturn out;\r\n\t}\r\n\r\n\tasync peekAll() {\r\n\t\tawait this.loadIntoBuffer(Infinity);\r\n\t\treturn this.buf.slice();\r\n\t}\r\n\r\n\tdestroy() {\r\n\t\tthis.atEOF = true;\r\n\t\tthis.buf = [];\r\n\t\tthis.resolvePush();\r\n\t\treturn this._destroy();\r\n\t}\r\n\r\n\t// eslint-disable-next-line no-restricted-globals\r\n\t[Symbol.asyncIterator]() { return this; }\r\n\tasync next() {\r\n\t\tif (this.buf.length) return {value: this.buf.shift() as T, done: false as const};\r\n\t\tawait this.loadIntoBuffer(1, true);\r\n\t\tif (!this.buf.length) return {value: undefined, done: true as const};\r\n\t\treturn {value: this.buf.shift() as T, done: false as const};\r\n\t}\r\n\r\n\tasync pipeTo(outStream: ObjectWriteStream<T>, options: {noEnd?: boolean} = {}) {\r\n\t\tlet value, done;\r\n\t\twhile (({value, done} = await this.next(), !done)) {\r\n\t\t\tawait outStream.write(value!);\r\n\t\t}\r\n\t\tif (!options.noEnd) return outStream.writeEnd();\r\n\t}\r\n}\r\n\r\ninterface ObjectWriteStreamOptions<T> {\r\n\t_writableState?: any;\r\n\tnodeStream?: NodeJS.WritableStream;\r\n\twrite?: (this: ObjectWriteStream<T>, data: T) => Promise<any> | undefined;\r\n\twriteEnd?: (this: ObjectWriteStream<T>) => Promise<any>;\r\n}\r\n\r\nexport class ObjectWriteStream<T> {\r\n\tisReadable: boolean;\r\n\tisWritable: true;\r\n\tnodeWritableStream: NodeJS.WritableStream | null;\r\n\r\n\tconstructor(optionsOrStream: ObjectWriteStreamOptions<T> | NodeJS.WritableStream = {}) {\r\n\t\tthis.isReadable = false;\r\n\t\tthis.isWritable = true;\r\n\t\tthis.nodeWritableStream = null;\r\n\r\n\t\tlet options: ObjectWriteStreamOptions<T> = optionsOrStream as any;\r\n\t\tif (options._writableState) {\r\n\t\t\toptions = {nodeStream: optionsOrStream as NodeJS.WritableStream};\r\n\t\t}\r\n\t\tif (options.nodeStream) {\r\n\t\t\tconst nodeStream: NodeJS.WritableStream = options.nodeStream;\r\n\t\t\tthis.nodeWritableStream = nodeStream;\r\n\r\n\t\t\toptions.write = function (data: T) {\r\n\t\t\t\tconst result = this.nodeWritableStream!.write(data as unknown as string);\r\n\t\t\t\tif (result === false) {\r\n\t\t\t\t\treturn new Promise<void>(resolve => {\r\n\t\t\t\t\t\tthis.nodeWritableStream!.once('drain', () => {\r\n\t\t\t\t\t\t\tresolve();\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Prior to Node v10.12.0, attempting to close STDOUT or STDERR will throw\r\n\t\t\tif (nodeStream !== process.stdout && nodeStream !== process.stderr) {\r\n\t\t\t\toptions.writeEnd = function () {\r\n\t\t\t\t\treturn new Promise<void>(resolve => {\r\n\t\t\t\t\t\tthis.nodeWritableStream!.end(() => resolve());\r\n\t\t\t\t\t});\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (options.write) this._write = options.write;\r\n\t\tif (options.writeEnd) this._writeEnd = options.writeEnd;\r\n\t}\r\n\r\n\twrite(elem: T | null): void | Promise<void> {\r\n\t\tif (elem === null) {\r\n\t\t\treturn this.writeEnd();\r\n\t\t}\r\n\t\treturn this._write(elem);\r\n\t}\r\n\r\n\t_write(elem: T): void | Promise<void> {\r\n\t\tthrow new Error(`WriteStream needs to be subclassed and the _write function needs to be implemented.`);\r\n\t}\r\n\r\n\t_writeEnd(): void | Promise<void> {}\r\n\r\n\tasync writeEnd(elem?: T): Promise<void> {\r\n\t\tif (elem !== undefined) {\r\n\t\t\tawait this.write(elem);\r\n\t\t}\r\n\t\treturn this._writeEnd();\r\n\t}\r\n}\r\n\r\ninterface ObjectReadWriteStreamOptions<T> {\r\n\tread?: (this: ObjectReadStream<T>) => void | Promise<void>;\r\n\tpause?: (this: ObjectReadStream<T>) => void | Promise<void>;\r\n\tdestroy?: (this: ObjectReadStream<T>) => void | Promise<void>;\r\n\twrite?: (this: ObjectWriteStream<T>, elem: T) => Promise<any> | undefined | void;\r\n\twriteEnd?: () => Promise<any> | undefined | void;\r\n}\r\n\r\nexport class ObjectReadWriteStream<T> extends ObjectReadStream<T> implements ObjectWriteStream<T> {\r\n\tisReadable: true;\r\n\tisWritable: true;\r\n\tnodeWritableStream: NodeJS.WritableStream | null;\r\n\r\n\tconstructor(options: ObjectReadWriteStreamOptions<T> = {}) {\r\n\t\tsuper(options);\r\n\t\tthis.isReadable = true;\r\n\t\tthis.isWritable = true;\r\n\t\tthis.nodeWritableStream = null;\r\n\t\tif (options.write) this._write = options.write;\r\n\t\tif (options.writeEnd) this._writeEnd = options.writeEnd;\r\n\t}\r\n\r\n\twrite(elem: T): void | Promise<void> {\r\n\t\treturn this._write(elem);\r\n\t}\r\n\r\n\t_write(elem: T): void | Promise<void> {\r\n\t\tthrow new Error(`WriteStream needs to be subclassed and the _write function needs to be implemented.`);\r\n\t}\r\n\t/** In a ReadWriteStream, _read does not need to be implemented. */\r\n\t_read() {}\r\n\r\n\t_writeEnd(): void | Promise<void> {}\r\n\r\n\tasync writeEnd() {\r\n\t\treturn this._writeEnd();\r\n\t}\r\n}\r\n\r\nexport function readAll(nodeStream: NodeJS.ReadableStream, encoding?: any) {\r\n\treturn new ReadStream(nodeStream).readAll(encoding);\r\n}\r\n\r\nexport function stdin() {\r\n\treturn new ReadStream(process.stdin);\r\n}\r\n\r\nexport function stdout() {\r\n\treturn new WriteStream(process.stdout);\r\n}\r\n\r\nexport function stdpipe(stream: WriteStream | ReadStream | ReadWriteStream) {\r\n\tconst promises = [];\r\n\tif ((stream as ReadStream | WriteStream & {pipeTo: undefined}).pipeTo) {\r\n\t\tpromises.push((stream as ReadStream).pipeTo(stdout()));\r\n\t}\r\n\tif ((stream as WriteStream | ReadStream & {write: undefined}).write) {\r\n\t\tpromises.push(stdin().pipeTo(stream as WriteStream));\r\n\t}\r\n\treturn Promise.all(promises);\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
