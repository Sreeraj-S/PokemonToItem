{
  "version": 3,
  "sources": ["../../../../../data/mods/gen1/scripts.ts"],
  "sourcesContent": ["/**\r\n * Gen 1 mechanics are fairly different to those we know on current gen.\r\n * Therefor we need to make a lot of changes to the battle engine for this game simulation.\r\n * This generation inherits all the changes from older generations, that must be taken into account when editing code.\r\n */\r\n\r\nconst SKIP_LASTDAMAGE = new Set([\r\n\t'confuseray', 'conversion', 'counter', 'focusenergy', 'glare', 'haze', 'leechseed', 'lightscreen',\r\n\t'mimic', 'mist', 'poisongas', 'poisonpowder', 'recover', 'reflect', 'rest', 'softboiled',\r\n\t'splash', 'stunspore', 'substitute', 'supersonic', 'teleport', 'thunderwave', 'toxic', 'transform',\r\n]);\r\n\r\nconst TWO_TURN_MOVES = ['dig', 'fly', 'razorwind', 'skullbash', 'skyattack', 'solarbeam'];\r\n\r\nexport const Scripts: ModdedBattleScriptsData = {\r\n\tinherit: 'gen2',\r\n\tgen: 1,\r\n\tinit() {\r\n\t\tfor (const i in this.data.Pokedex) {\r\n\t\t\t(this.data.Pokedex[i] as any).gender = 'N';\r\n\t\t\t(this.data.Pokedex[i] as any).eggGroups = null;\r\n\t\t}\r\n\t},\r\n\t// BattlePokemon scripts.\r\n\tpokemon: {\r\n\t\tgetStat(statName, unmodified) {\r\n\t\t\t// @ts-ignore - type checking prevents 'hp' from being passed, but we're paranoid\r\n\t\t\tif (statName === 'hp') throw new Error(\"Please read `maxhp` directly\");\r\n\t\t\tif (unmodified) return this.baseStoredStats[statName];\r\n\t\t\treturn this.modifiedStats![statName];\r\n\t\t},\r\n\t\t// Gen 1 function to apply a stat modification that is only active until the stat is recalculated or mon switched.\r\n\t\tmodifyStat(statName, modifier) {\r\n\t\t\tif (!(statName in this.storedStats)) throw new Error(\"Invalid `statName` passed to `modifyStat`\");\r\n\t\t\tconst modifiedStats = this.battle.clampIntRange(Math.floor(this.modifiedStats![statName] * modifier), 1);\r\n\t\t\tthis.modifiedStats![statName] = modifiedStats;\r\n\t\t},\r\n\t\t// In generation 1, boosting function increases the stored modified stat and checks for opponent's status.\r\n\t\tboostBy(boost) {\r\n\t\t\tlet changed: boolean | number = false;\r\n\t\t\tlet i: BoostID;\r\n\t\t\tfor (i in boost) {\r\n\t\t\t\tconst delta = boost[i];\r\n\t\t\t\tif (delta === undefined) continue;\r\n\t\t\t\tif (delta > 0 && this.boosts[i] >= 6) continue;\r\n\t\t\t\tif (delta < 0 && this.boosts[i] <= -6) continue;\r\n\t\t\t\tif (i === 'evasion' || i === 'accuracy') {\r\n\t\t\t\t\tthis.boosts[i] += delta;\r\n\t\t\t\t\tif (this.boosts[i] > 6) {\r\n\t\t\t\t\t\tthis.boosts[i] = 6;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this.boosts[i] < -6) {\r\n\t\t\t\t\t\tthis.boosts[i] = -6;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tchanged = true;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t// Stat being modified is not evasion or accuracy, so change modifiedStats.\r\n\t\t\t\tif (delta > 0) {\r\n\t\t\t\t\tif (this.modifiedStats![i] === 999) {\r\n\t\t\t\t\t\t// Intended max stat value\r\n\t\t\t\t\t\tthis.boosts[i] += delta;\r\n\t\t\t\t\t\tif (this.boosts[i] > 6) {\r\n\t\t\t\t\t\t\tthis.boosts[i] = 6;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.boosts[i]--;\r\n\t\t\t\t\t\t// changed = 0 corresponds to increasing stats at 999 (or decreasing at 1).\r\n\t\t\t\t\t\tchanged = 0;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.boosts[i] += delta;\r\n\t\t\t\t\t\tif (this.boosts[i] > 6) {\r\n\t\t\t\t\t\t\tthis.boosts[i] = 6;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (delta < 0) {\r\n\t\t\t\t\tif (this.modifiedStats![i] === 1) {\r\n\t\t\t\t\t\t// Minimum stat value\r\n\t\t\t\t\t\tthis.boosts[i] += delta;\r\n\t\t\t\t\t\tif (this.boosts[i] < -6) {\r\n\t\t\t\t\t\t\tthis.boosts[i] = -6;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.boosts[i]++;\r\n\t\t\t\t\t\t// changed = 0 corresponds to increasing stats at 999 (or decreasing at 1).\r\n\t\t\t\t\t\tchanged = 0;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.boosts[i] += delta;\r\n\t\t\t\t\t\tif (this.boosts[i] < -6) {\r\n\t\t\t\t\t\t\tthis.boosts[i] = -6;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (changed) {\r\n\t\t\t\t\t// Recalculate the modified stat\r\n\t\t\t\t\tthis.modifiedStats![i] = this.storedStats[i];\r\n\t\t\t\t\tif (this.boosts[i] >= 0) {\r\n\t\t\t\t\t\tthis.modifyStat!(i, [1, 1.5, 2, 2.5, 3, 3.5, 4][this.boosts[i]]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.modifyStat!(i, [100, 66, 50, 40, 33, 28, 25][-this.boosts[i]] / 100);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (delta > 0 && this.modifiedStats![i] > 999) {\r\n\t\t\t\t\t\t// Cap the stat at 999\r\n\t\t\t\t\t\tthis.modifiedStats![i] = 999;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn changed;\r\n\t\t},\r\n\t\tclearBoosts() {\r\n\t\t\tlet i: BoostID;\r\n\t\t\tfor (i in this.boosts) {\r\n\t\t\t\tthis.boosts[i] = 0;\r\n\t\t\t\t// Recalculate the modified stat\r\n\t\t\t\tif (i === 'evasion' || i === 'accuracy') continue;\r\n\t\t\t\tthis.modifiedStats![i] = this.storedStats[i];\r\n\t\t\t}\r\n\t\t},\r\n\t},\r\n\tactions: {\r\n\t\t// This function is the main one when running a move.\r\n\t\t// It deals with the beforeMove event.\r\n\t\t// It also deals with how PP reduction works on gen 1.\r\n\t\trunMove(moveOrMoveName, pokemon, targetLoc, sourceEffect) {\r\n\t\t\tconst target = this.battle.getTarget(pokemon, moveOrMoveName, targetLoc);\r\n\t\t\tconst move = this.battle.dex.getActiveMove(moveOrMoveName);\r\n\t\t\tif (target?.subFainted) target.subFainted = null;\r\n\r\n\t\t\tthis.battle.setActiveMove(move, pokemon, target);\r\n\r\n\t\t\tif (pokemon.moveThisTurn || !this.battle.runEvent('BeforeMove', pokemon, target, move)) {\r\n\t\t\t\tthis.battle.clearActiveMove(true);\r\n\t\t\t\t// This is only run for sleep.\r\n\t\t\t\tthis.battle.runEvent('AfterMoveSelf', pokemon, target, move);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (move.beforeMoveCallback) {\r\n\t\t\t\tif (move.beforeMoveCallback.call(this.battle, pokemon, target, move)) {\r\n\t\t\t\t\tthis.battle.clearActiveMove(true);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlet lockedMove = this.battle.runEvent('LockMove', pokemon);\r\n\t\t\tif (lockedMove === true) lockedMove = false;\r\n\t\t\tif (\r\n\t\t\t\t(!lockedMove &&\r\n\t\t\t\t(!pokemon.volatiles['partialtrappinglock'] || pokemon.volatiles['partialtrappinglock'].locked !== target))\r\n\t\t\t) {\r\n\t\t\t\tpokemon.deductPP(move, null, target);\r\n\t\t\t} else {\r\n\t\t\t\tsourceEffect = move;\r\n\t\t\t\tif (pokemon.volatiles['twoturnmove']) {\r\n\t\t\t\t\t// Two-turn moves like Sky Attack deduct PP on their second turn.\r\n\t\t\t\t\tpokemon.deductPP(pokemon.volatiles['twoturnmove'].originalMove, null, target);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (pokemon.volatiles['partialtrappinglock'] && target !== pokemon.volatiles['partialtrappinglock'].locked) {\r\n\t\t\t\tconst moveSlot = pokemon.moveSlots.find(ms => ms.id === move.id);\r\n\t\t\t\tif (moveSlot && moveSlot.pp < 0) {\r\n\t\t\t\t\tmoveSlot.pp = 63;\r\n\t\t\t\t\tthis.battle.hint(\"In Gen 1, if a player is forced to use a move with 0 PP, the move will underflow to have 63 PP.\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.useMove(move, pokemon, target, sourceEffect);\r\n\t\t\t// Restore PP if the move is the first turn of a charging move. Save the move from which PP should be deducted if the move succeeds.\r\n\t\t\tif (pokemon.volatiles['twoturnmove']) {\r\n\t\t\t\tpokemon.deductPP(move, -1, target);\r\n\t\t\t\tpokemon.volatiles['twoturnmove'].originalMove = move.id;\r\n\t\t\t}\r\n\t\t},\r\n\t\t// This function deals with AfterMoveSelf events.\r\n\t\t// This leads with partial trapping moves shenanigans after the move has been used.\r\n\t\tuseMove(moveOrMoveName, pokemon, target, sourceEffect) {\r\n\t\t\tif (!sourceEffect && this.battle.effect.id) sourceEffect = this.battle.effect;\r\n\t\t\tconst baseMove = this.battle.dex.moves.get(moveOrMoveName);\r\n\t\t\tlet move = this.battle.dex.getActiveMove(baseMove);\r\n\t\t\tif (target === undefined) target = this.battle.getRandomTarget(pokemon, move);\r\n\t\t\tif (move.target === 'self') {\r\n\t\t\t\ttarget = pokemon;\r\n\t\t\t}\r\n\t\t\tif (sourceEffect) move.sourceEffect = sourceEffect.id;\r\n\r\n\t\t\tthis.battle.singleEvent('ModifyMove', move, null, pokemon, target, move, move);\r\n\t\t\tif (baseMove.target !== move.target) {\r\n\t\t\t\t// Target changed in ModifyMove, so we must adjust it here\r\n\t\t\t\ttarget = this.battle.getRandomTarget(pokemon, move);\r\n\t\t\t}\r\n\t\t\tmove = this.battle.runEvent('ModifyMove', pokemon, target, move, move);\r\n\t\t\tif (baseMove.target !== move.target) {\r\n\t\t\t\t// Check again, this shouldn't ever happen on Gen 1.\r\n\t\t\t\ttarget = this.battle.getRandomTarget(pokemon, move);\r\n\t\t\t}\r\n\t\t\t// The charging turn of a two-turn move does not update pokemon.lastMove\r\n\t\t\tif (!TWO_TURN_MOVES.includes(move.id) || pokemon.volatiles['twoturnmove']) pokemon.lastMove = move;\r\n\r\n\t\t\tconst moveResult = this.useMoveInner(moveOrMoveName, pokemon, target, sourceEffect);\r\n\r\n\t\t\tif (move.id !== 'metronome') {\r\n\t\t\t\tif (move.id !== 'mirrormove' ||\r\n\t\t\t\t\t(!pokemon.side.foe.active[0]?.lastMove || pokemon.side.foe.active[0].lastMove?.id === 'mirrormove')) {\r\n\t\t\t\t\t// The move is our 'final' move (a failed Mirror Move, or any move that isn't Metronome or Mirror Move).\r\n\t\t\t\t\tpokemon.side.lastMove = move;\r\n\r\n\t\t\t\t\tif (pokemon.volatiles['lockedmove']?.time <= 0) pokemon.removeVolatile('lockedmove');\r\n\r\n\t\t\t\t\t// If target fainted\r\n\t\t\t\t\tif (target && target.hp <= 0) {\r\n\t\t\t\t\t\t// We remove recharge\r\n\t\t\t\t\t\tif (pokemon.volatiles['mustrecharge']) pokemon.removeVolatile('mustrecharge');\r\n\t\t\t\t\t\tdelete pokemon.volatiles['partialtrappinglock'];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (pokemon.volatiles['mustrecharge']) this.battle.add('-mustrecharge', pokemon);\r\n\t\t\t\t\t\tif (pokemon.hp) this.battle.runEvent('AfterMoveSelf', pokemon, target, move);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// For partial trapping moves, we are saving the target\r\n\t\t\t\t\tif (move.volatileStatus === 'partiallytrapped' && target && target.hp > 0) {\r\n\t\t\t\t\t\t// Let's check if the lock exists\r\n\t\t\t\t\t\tif (pokemon.volatiles['partialtrappinglock'] && target.volatiles['partiallytrapped']) {\r\n\t\t\t\t\t\t\t// Here the partialtrappinglock volatile has been already applied\r\n\t\t\t\t\t\t\tconst sourceVolatile = pokemon.volatiles['partialtrappinglock'];\r\n\t\t\t\t\t\t\tconst targetVolatile = target.volatiles['partiallytrapped'];\r\n\t\t\t\t\t\t\tif (!sourceVolatile.locked) {\r\n\t\t\t\t\t\t\t\t// If it's the first hit, we save the target\r\n\t\t\t\t\t\t\t\tsourceVolatile.locked = target;\r\n\t\t\t\t\t\t\t} else if (target !== pokemon && target !== sourceVolatile.locked) {\r\n\t\t\t\t\t\t\t\t// Our target switched out! Re-roll the duration, damage, and accuracy.\r\n\t\t\t\t\t\t\t\tconst duration = this.battle.sample([2, 2, 2, 3, 3, 3, 4, 5]);\r\n\t\t\t\t\t\t\t\tsourceVolatile.duration = duration;\r\n\t\t\t\t\t\t\t\tsourceVolatile.locked = target;\r\n\t\t\t\t\t\t\t\t// Duration reset thus partially trapped at 2 always.\r\n\t\t\t\t\t\t\t\ttargetVolatile.duration = 2;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} // If we move to here, the move failed and there's no partial trapping lock.\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn moveResult;\r\n\t\t},\r\n\t\t// This is the function that actually uses the move, running ModifyMove events.\r\n\t\t// It uses the move and then deals with the effects after the move.\r\n\t\tuseMoveInner(moveOrMoveName, pokemon, target, sourceEffect) {\r\n\t\t\tif (!sourceEffect && this.battle.effect.id) sourceEffect = this.battle.effect;\r\n\t\t\tconst baseMove = this.battle.dex.moves.get(moveOrMoveName);\r\n\t\t\tlet move = this.battle.dex.getActiveMove(baseMove);\r\n\t\t\tif (target === undefined) target = this.battle.getRandomTarget(pokemon, move);\r\n\t\t\tif (move.target === 'self') {\r\n\t\t\t\ttarget = pokemon;\r\n\t\t\t}\r\n\t\t\tif (sourceEffect) move.sourceEffect = sourceEffect.id;\r\n\r\n\t\t\tthis.battle.setActiveMove(move, pokemon, target);\r\n\r\n\t\t\tthis.battle.singleEvent('ModifyMove', move, null, pokemon, target, move, move);\r\n\t\t\tif (baseMove.target !== move.target) {\r\n\t\t\t\t// Target changed in ModifyMove, so we must adjust it here\r\n\t\t\t\ttarget = this.battle.getRandomTarget(pokemon, move);\r\n\t\t\t}\r\n\t\t\tmove = this.battle.runEvent('ModifyMove', pokemon, target, move, move);\r\n\t\t\tif (baseMove.target !== move.target) {\r\n\t\t\t\t// Check again, this shouldn't ever happen on Gen 1.\r\n\t\t\t\ttarget = this.battle.getRandomTarget(pokemon, move);\r\n\t\t\t\tthis.battle.debug('not a gen 1 mechanic');\r\n\t\t\t}\r\n\t\t\tif (!move) return false;\r\n\r\n\t\t\tlet attrs = '';\r\n\t\t\tif (pokemon.fainted) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tif (sourceEffect) attrs += '|[from]' + this.battle.dex.conditions.get(sourceEffect);\r\n\t\t\tthis.battle.addMove('move', pokemon, move.name, target + attrs);\r\n\r\n\t\t\tif (!this.battle.singleEvent('Try', move, null, pokemon, target, move)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tif (!this.battle.singleEvent('TryMove', move, null, pokemon, target, move) ||\r\n\t\t\t\t!this.battle.runEvent('TryMove', pokemon, target, move)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tif (move.ignoreImmunity === undefined) {\r\n\t\t\t\tmove.ignoreImmunity = (move.category === 'Status');\r\n\t\t\t}\r\n\r\n\t\t\tlet damage: number | undefined | false | '' = false;\r\n\t\t\tif (!target || target.fainted) {\r\n\t\t\t\tthis.battle.attrLastMove('[notarget]');\r\n\t\t\t\tthis.battle.add('-notarget');\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t// Store 0 damage for last damage if the move is not in the array.\r\n\t\t\tif (!SKIP_LASTDAMAGE.has(move.id)) this.battle.lastDamage = 0;\r\n\r\n\t\t\tdamage = this.tryMoveHit(target, pokemon, move);\r\n\r\n\t\t\t// Disable and Selfdestruct/Explosion boost rage, regardless of whether they miss/fail.\r\n\t\t\tif (target.boosts.atk < 6 && (move.selfdestruct || move.id === 'disable') && target.volatiles['rage']) {\r\n\t\t\t\tthis.battle.boost({atk: 1}, target, pokemon, this.dex.conditions.get('rage'));\r\n\t\t\t\tthis.battle.hint(`In Gen 1, using ${move.name} causes the target to build Rage, ` +\r\n\t\t\t\t`even if it misses or fails`, true);\r\n\t\t\t}\r\n\r\n\t\t\t// Go ahead with results of the used move.\r\n\t\t\tif (damage === false) {\r\n\t\t\t\tthis.battle.singleEvent('MoveFail', move, null, target, pokemon, move);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tif (!move.negateSecondary) {\r\n\t\t\t\tthis.battle.singleEvent('AfterMoveSecondarySelf', move, null, pokemon, target, move);\r\n\t\t\t\tthis.battle.runEvent('AfterMoveSecondarySelf', pokemon, target, move);\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t},\r\n\t\t// This function attempts a move hit and returns the attempt result before the actual hit happens.\r\n\t\t// It deals with partial trapping weirdness and accuracy bugs as well.\r\n\t\ttryMoveHit(target, pokemon, move) {\r\n\t\t\tlet damage: number | false | undefined = 0;\r\n\r\n\t\t\t// Add Thrashing effect before the move does damage, or add confusion if Thrash effect is ending\r\n\t\t\tif (move?.self?.volatileStatus === 'lockedmove') {\r\n\t\t\t\tif (pokemon.volatiles['lockedmove']) {\r\n\t\t\t\t\tpokemon.volatiles['lockedmove'].time--;\r\n\t\t\t\t\tif (!pokemon.volatiles['lockedmove'].time) {\r\n\t\t\t\t\t\t// Confusion begins even if already confused.\r\n\t\t\t\t\t\t// Remove lockedmove volatile when dealing with after move effects.\r\n\t\t\t\t\t\tdelete pokemon.volatiles['confusion'];\r\n\t\t\t\t\t\tpokemon.addVolatile('confusion', pokemon, this.dex.conditions.get('lockedmove'));\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpokemon.addVolatile('lockedmove', pokemon, move);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// First, check if the target is semi-invulnerable\r\n\t\t\tlet hitResult = this.battle.runEvent('Invulnerability', target, pokemon, move);\r\n\t\t\tif (hitResult === false) {\r\n\t\t\t\tthis.battle.attrLastMove('[miss]');\r\n\t\t\t\tthis.battle.add('-miss', pokemon);\r\n\t\t\t\tif (move.selfdestruct) {\r\n\t\t\t\t\tthis.battle.faint(pokemon, pokemon, move);\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// Then, check if the Pok\u00E9mon is immune to this move.\r\n\t\t\tif (\r\n\t\t\t\t(!move.ignoreImmunity || (move.ignoreImmunity !== true && !move.ignoreImmunity[move.type])) &&\r\n\t\t\t\t!target.runImmunity(move.type, true)\r\n\t\t\t) {\r\n\t\t\t\tif (move.selfdestruct) {\r\n\t\t\t\t\tthis.battle.faint(pokemon, pokemon, move);\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\thitResult = this.battle.singleEvent('TryImmunity', move, null, target, pokemon, move);\r\n\t\t\tif (hitResult === false) {\r\n\t\t\t\tthis.battle.add('-immune', target);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// Now, let's calculate the accuracy.\r\n\t\t\tlet accuracy = move.accuracy;\r\n\r\n\t\t\t// Partial trapping moves: true accuracy while it lasts\r\n\t\t\tif (move.volatileStatus === 'partiallytrapped' && target === pokemon.volatiles['partialtrappinglock']?.locked) {\r\n\t\t\t\taccuracy = true;\r\n\t\t\t}\r\n\r\n\t\t\t// If a sleep inducing move is used while the user is recharging, the accuracy is true.\r\n\t\t\tif (move.status === 'slp' && target && target.volatiles['mustrecharge']) {\r\n\t\t\t\taccuracy = true;\r\n\t\t\t}\r\n\r\n\t\t\t// OHKO moves only have a chance to hit if the user is at least as fast as the target\r\n\t\t\tif (move.ohko) {\r\n\t\t\t\tif (target.getStat('spe') > pokemon.getStat('spe')) {\r\n\t\t\t\t\tthis.battle.add('-immune', target, '[ohko]');\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Calculate true accuracy for gen 1, which uses 0-255.\r\n\t\t\t// Gen 1 uses the same boost table for accuracy and evasiveness as every other stat\r\n\t\t\tconst boostTable = [25, 28, 33, 40, 50, 66, 100, 150, 200, 250, 300, 350, 400];\r\n\t\t\tif (accuracy !== true) {\r\n\t\t\t\taccuracy = Math.floor(accuracy * 255 / 100);\r\n\t\t\t\t// Rage and Thrash/Petal Dance accuracy bug\r\n\t\t\t\tif (pokemon.volatiles['lockedmove']) accuracy = pokemon.volatiles['lockedmove'].accuracy;\r\n\t\t\t\tif (pokemon.volatiles['rage']) accuracy = pokemon.volatiles['rage'].accuracy;\r\n\r\n\t\t\t\t// This line is just to satisfy TypeScript, accuracy should never be true at this point\r\n\t\t\t\tif (accuracy !== true) {\r\n\t\t\t\t\t// Check also for accuracy modifiers.\r\n\t\t\t\t\tif (!move.ignoreAccuracy) {\r\n\t\t\t\t\t\taccuracy = Math.floor(accuracy * (boostTable[pokemon.boosts.accuracy + 6] / 100));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!move.ignoreEvasion) {\r\n\t\t\t\t\t\taccuracy = Math.floor(accuracy * (boostTable[-target.boosts.evasion + 6] / 100));\r\n\t\t\t\t\t}\r\n\t\t\t\t\taccuracy = this.battle.clampIntRange(accuracy, 1, 255);\r\n\t\t\t\t}\r\n\t\t\t\tif (pokemon.volatiles['lockedmove']) pokemon.volatiles['lockedmove'].accuracy = accuracy;\r\n\t\t\t\tif (pokemon.volatiles['rage']) pokemon.volatiles['rage'].accuracy = accuracy;\r\n\t\t\t}\r\n\t\t\taccuracy = this.battle.runEvent('Accuracy', target, pokemon, move, accuracy);\r\n\t\t\t// Moves that target the user do not suffer from the 1/256 miss chance.\r\n\t\t\tif (move.target === 'self' && accuracy !== true) accuracy++;\r\n\t\t\t// 1/256 chance of missing always, no matter what. Besides the aforementioned exceptions.\r\n\t\t\tif (accuracy !== true && !this.battle.randomChance(accuracy, 256)) {\r\n\t\t\t\tthis.battle.attrLastMove('[miss]');\r\n\t\t\t\tthis.battle.add('-miss', pokemon);\r\n\t\t\t\tif (accuracy === 255) this.battle.hint(\"In Gen 1, moves with 100% accuracy can still miss 1/256 of the time.\");\r\n\t\t\t\tdamage = false;\r\n\t\t\t\tthis.battle.lastDamage = 0;\r\n\t\t\t}\r\n\r\n\t\t\t// If damage is 0 and not false it means it didn't miss, let's calc.\r\n\t\t\tif (damage !== false) {\r\n\t\t\t\tif (move.multihit) {\r\n\t\t\t\t\tlet hits = move.multihit;\r\n\t\t\t\t\tif (Array.isArray(hits)) {\r\n\t\t\t\t\t\t// Yes, it's hardcoded... meh\r\n\t\t\t\t\t\tif (hits[0] === 2 && hits[1] === 5) {\r\n\t\t\t\t\t\t\thits = this.battle.sample([2, 2, 2, 3, 3, 3, 4, 5]);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\thits = this.battle.random(hits[0], hits[1] + 1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\thits = Math.floor(hits);\r\n\t\t\t\t\t// In gen 1, all the hits have the same damage for multihits move\r\n\t\t\t\t\tlet moveDamage: number | undefined | false = 0;\r\n\t\t\t\t\tlet i: number;\r\n\t\t\t\t\tfor (i = 0; i < hits && target.hp && pokemon.hp; i++) {\r\n\t\t\t\t\t\tmove.hit = i + 1;\r\n\t\t\t\t\t\tif (move.hit === hits) move.lastHit = true;\r\n\t\t\t\t\t\tmoveDamage = this.moveHit(target, pokemon, move);\r\n\t\t\t\t\t\tif (moveDamage === false) break;\r\n\t\t\t\t\t\tdamage = (moveDamage || 0);\r\n\t\t\t\t\t\t// Move damage is fixed to be the first move's damage\r\n\t\t\t\t\t\tif (i === 0) move.damage = damage;\r\n\t\t\t\t\t\tif (target.subFainted) {\r\n\t\t\t\t\t\t\ti++;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmove.damage = null;\r\n\t\t\t\t\tif (i === 0) return 1;\r\n\t\t\t\t\tthis.battle.add('-hitcount', target, i);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdamage = this.moveHit(target, pokemon, move);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (move.category !== 'Status') {\r\n\t\t\t\ttarget.gotAttacked(move, damage, pokemon);\r\n\t\t\t}\r\n\r\n\t\t\tif (move.selfdestruct) {\r\n\t\t\t\tif (!target.subFainted) {\r\n\t\t\t\t\tthis.battle.faint(pokemon, pokemon, move);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.battle.hint(`In Gen 1, the user of ${move.name} will not take damage if it breaks a Substitute.`);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// The move missed.\r\n\t\t\tif (damage === false) {\r\n\t\t\t\t// Delete the partial trap lock if necessary.\r\n\t\t\t\tdelete pokemon.volatiles['partialtrappinglock'];\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tif (move.ohko) this.battle.add('-ohko');\r\n\r\n\t\t\tif (!move.negateSecondary) {\r\n\t\t\t\tthis.battle.singleEvent('AfterMoveSecondary', move, null, target, pokemon, move);\r\n\t\t\t\tthis.battle.runEvent('AfterMoveSecondary', target, pokemon, move);\r\n\t\t\t}\r\n\r\n\t\t\treturn damage;\r\n\t\t},\r\n\t\t// It deals with the actual move hit, as the name indicates, dealing damage and/or effects.\r\n\t\t// This function also deals with the Gen 1 Substitute behaviour on the hitting process.\r\n\t\tmoveHit(target, pokemon, move, moveData, isSecondary, isSelf) {\r\n\t\t\tlet damage: number | false | null | undefined = 0;\r\n\r\n\t\t\tif (!isSecondary && !isSelf) this.battle.setActiveMove(move, pokemon, target);\r\n\t\t\tlet hitResult: number | boolean = true;\r\n\t\t\tif (!moveData) moveData = move;\r\n\r\n\t\t\tif (move.ignoreImmunity === undefined) {\r\n\t\t\t\tmove.ignoreImmunity = (move.category === 'Status');\r\n\t\t\t}\r\n\r\n\t\t\t// We get the sub to the target to see if it existed\r\n\t\t\tconst targetSub = (target) ? target.volatiles['substitute'] : false;\r\n\t\t\tconst targetHadSub = (targetSub !== null && targetSub !== false && (typeof targetSub !== 'undefined'));\r\n\t\t\tlet targetHasSub: boolean | undefined = undefined;\r\n\r\n\t\t\tif (target) {\r\n\t\t\t\thitResult = this.battle.singleEvent('TryHit', moveData, {}, target, pokemon, move);\r\n\r\n\t\t\t\t// Handle here the applying of partial trapping moves to Pok\u00E9mon with Substitute\r\n\t\t\t\tif (targetSub && moveData.volatileStatus && moveData.volatileStatus === 'partiallytrapped') {\r\n\t\t\t\t\ttarget.addVolatile(moveData.volatileStatus, pokemon, move);\r\n\t\t\t\t\tif (!pokemon.volatiles['partialtrappinglock'] || pokemon.volatiles['partialtrappinglock'].duration > 1) {\r\n\t\t\t\t\t\ttarget.volatiles[moveData.volatileStatus].duration = 2;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!hitResult) {\r\n\t\t\t\t\tif (hitResult === false) this.battle.add('-fail', target);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Only run the hit events for the hit itself, not the secondary or self hits\r\n\t\t\t\tif (!isSelf && !isSecondary) {\r\n\t\t\t\t\thitResult = this.battle.runEvent('TryHit', target, pokemon, move);\r\n\t\t\t\t\tif (!hitResult) {\r\n\t\t\t\t\t\tif (hitResult === false) this.battle.add('-fail', target);\r\n\t\t\t\t\t\t// Special Substitute hit flag\r\n\t\t\t\t\t\tif (hitResult !== 0) {\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!this.battle.runEvent('TryFieldHit', target, pokemon, move)) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (isSecondary && !moveData.self) {\r\n\t\t\t\t\thitResult = this.battle.runEvent('TrySecondaryHit', target, pokemon, moveData);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (hitResult === 0) {\r\n\t\t\t\t\ttargetHasSub = !!(target?.volatiles['substitute']);\r\n\t\t\t\t\ttarget = null;\r\n\t\t\t\t} else if (!hitResult) {\r\n\t\t\t\t\tif (hitResult === false) this.battle.add('-fail', target);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (target) {\r\n\t\t\t\tlet didSomething = false;\r\n\r\n\t\t\t\tdamage = this.getDamage(pokemon, target, moveData);\r\n\r\n\t\t\t\t// getDamage has several possible return values:\r\n\t\t\t\t//\r\n\t\t\t\t//   a number:\r\n\t\t\t\t//     means that much damage is dealt (0 damage still counts as dealing\r\n\t\t\t\t//     damage for the purposes of things like Static)\r\n\t\t\t\t//   false:\r\n\t\t\t\t//     gives error message: \"But it failed!\" and move ends\r\n\t\t\t\t//   null:\r\n\t\t\t\t//     the move ends, with no message (usually, a custom fail message\r\n\t\t\t\t//     was already output by an event handler)\r\n\t\t\t\t//   undefined:\r\n\t\t\t\t//     means no damage is dealt and the move continues\r\n\t\t\t\t//\r\n\t\t\t\t// basically, these values have the same meanings as they do for event\r\n\t\t\t\t// handlers.\r\n\r\n\t\t\t\tif (damage && damage > target.hp) {\r\n\t\t\t\t\tdamage = target.hp;\r\n\t\t\t\t}\r\n\t\t\t\tif ((damage || damage === 0) && !target.fainted) {\r\n\t\t\t\t\tdamage = this.battle.damage(damage, target, pokemon, move);\r\n\t\t\t\t\tif (!(damage || damage === 0)) return false;\r\n\t\t\t\t\tdidSomething = true;\r\n\t\t\t\t} else if (damage === false && typeof hitResult === 'undefined') {\r\n\t\t\t\t\tthis.battle.add('-fail', target);\r\n\t\t\t\t}\r\n\t\t\t\tif (damage === false || damage === null) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tif (moveData.boosts && target.hp) {\r\n\t\t\t\t\tconst willBoost = this.battle.boost(moveData.boosts, target, pokemon, move);\r\n\t\t\t\t\tif (!willBoost) {\r\n\t\t\t\t\t\tthis.battle.add('-fail', target);\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdidSomething = true;\r\n\t\t\t\t\t// Check the status of the Pok\u00E9mon whose turn is not.\r\n\t\t\t\t\t// When a move that affects stat levels is used, if the Pok\u00E9mon whose turn it is not right now is paralyzed or\r\n\t\t\t\t\t// burned, the correspoding stat penalties will be applied again to that Pok\u00E9mon.\r\n\t\t\t\t\tif (pokemon.side.foe.active[0].status) {\r\n\t\t\t\t\t\t// If it's paralysed, quarter its speed.\r\n\t\t\t\t\t\tif (pokemon.side.foe.active[0].status === 'par') {\r\n\t\t\t\t\t\t\tpokemon.side.foe.active[0].modifyStat!('spe', 0.25);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// If it's burned, halve its attack.\r\n\t\t\t\t\t\tif (pokemon.side.foe.active[0].status === 'brn') {\r\n\t\t\t\t\t\t\tpokemon.side.foe.active[0].modifyStat!('atk', 0.5);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (moveData.heal && !target.fainted) {\r\n\t\t\t\t\tconst d = target.heal(Math.floor(target.maxhp * moveData.heal[0] / moveData.heal[1]));\r\n\t\t\t\t\tif (!d) {\r\n\t\t\t\t\t\tthis.battle.add('-fail', target);\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.battle.add('-heal', target, target.getHealth);\r\n\t\t\t\t\tdidSomething = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (moveData.status) {\r\n\t\t\t\t\t// Gen 1 bug: If the target has just used hyperbeam and must recharge, its status will be ignored and put to sleep.\r\n\t\t\t\t\t// This does NOT revert the paralyse speed drop or the burn attack drop.\r\n\t\t\t\t\t// Also, being put to sleep clears the recharge condition.\r\n\t\t\t\t\tif (moveData.status === 'slp' && target.volatiles['mustrecharge']) {\r\n\t\t\t\t\t\t// The sleep move is guaranteed to hit in this situation, unless Sleep Clause activates.\r\n\t\t\t\t\t\t// Do not clear recharge in that case.\r\n\t\t\t\t\t\tif (target.setStatus(moveData.status, pokemon, move)) {\r\n\t\t\t\t\t\t\ttarget.removeVolatile('mustrecharge');\r\n\t\t\t\t\t\t\tthis.battle.hint(\r\n\t\t\t\t\t\t\t\t\"In Gen 1, if a Pok\u00E9mon that has just used Hyper Beam and has yet to recharge is targeted with a sleep inducing move, \" +\r\n\t\t\t\t\t\t\t\t\"any other status it may already have will be ignored and sleep will be induced regardless.\"\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (!target.status) {\r\n\t\t\t\t\t\tif (target.setStatus(moveData.status, pokemon, move)) {\r\n\t\t\t\t\t\t\t// Gen 1 mechanics: The burn attack drop and the paralyse speed drop are applied here directly on stat modifiers.\r\n\t\t\t\t\t\t\tif (moveData.status === 'brn') target.modifyStat!('atk', 0.5);\r\n\t\t\t\t\t\t\tif (moveData.status === 'par') target.modifyStat!('spe', 0.25);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (!isSecondary) {\r\n\t\t\t\t\t\tif (target.status === moveData.status) {\r\n\t\t\t\t\t\t\tthis.battle.add('-fail', target, target.status);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.battle.add('-fail', target);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdidSomething = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (moveData.forceStatus) {\r\n\t\t\t\t\tif (target.setStatus(moveData.forceStatus, pokemon, move)) {\r\n\t\t\t\t\t\tif (moveData.forceStatus === 'brn') target.modifyStat!('atk', 0.5);\r\n\t\t\t\t\t\tif (moveData.forceStatus === 'par') target.modifyStat!('spe', 0.25);\r\n\t\t\t\t\t\tdidSomething = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (moveData.volatileStatus) {\r\n\t\t\t\t\tif (target.addVolatile(moveData.volatileStatus, pokemon, move)) {\r\n\t\t\t\t\t\tdidSomething = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (moveData.sideCondition) {\r\n\t\t\t\t\tif (target.side.addSideCondition(moveData.sideCondition, pokemon, move)) {\r\n\t\t\t\t\t\tdidSomething = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (moveData.pseudoWeather) {\r\n\t\t\t\t\tif (this.battle.field.addPseudoWeather(moveData.pseudoWeather, pokemon, move)) {\r\n\t\t\t\t\t\tdidSomething = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Hit events\r\n\t\t\t\thitResult = this.battle.singleEvent('Hit', moveData, {}, target, pokemon, move);\r\n\t\t\t\tif (!isSelf && !isSecondary) {\r\n\t\t\t\t\tthis.battle.runEvent('Hit', target, pokemon, move);\r\n\t\t\t\t}\r\n\t\t\t\tif (!hitResult && !didSomething) {\r\n\t\t\t\t\tif (hitResult === false) this.battle.add('-fail', target);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (targetHasSub === undefined) targetHasSub = !!(target?.volatiles['substitute']);\r\n\r\n\t\t\t// Here's where self effects are applied.\r\n\t\t\tconst doSelf = (targetHadSub && targetHasSub) || !targetHadSub;\r\n\t\t\tif (moveData.self && (moveData.self.volatileStatus !== 'lockedmove') &&\r\n\t\t\t\t(doSelf || moveData.self.volatileStatus === 'partialtrappinglock')) {\r\n\t\t\t\tthis.moveHit(pokemon, pokemon, move, moveData.self, isSecondary, true);\r\n\t\t\t}\r\n\r\n\t\t\t// Now we can save the partial trapping damage.\r\n\t\t\tif (pokemon.volatiles['partialtrappinglock']) {\r\n\t\t\t\tpokemon.volatiles['partialtrappinglock'].damage = this.battle.lastDamage;\r\n\t\t\t}\r\n\r\n\t\t\t// Apply move secondaries.\r\n\t\t\tif (moveData.secondaries && target && target.hp > 0) {\r\n\t\t\t\tfor (const secondary of moveData.secondaries) {\r\n\t\t\t\t\t// Multi-hit moves only roll for status once\r\n\t\t\t\t\tif (!move.multihit || move.lastHit) {\r\n\t\t\t\t\t\t// We check here whether to negate the probable secondary status if it's para, burn, or freeze.\r\n\t\t\t\t\t\t// In the game, this is checked and if true, the random number generator is not called.\r\n\t\t\t\t\t\t// That means that a move that does not share the type of the target can status it.\r\n\t\t\t\t\t\t// If a move that was not fire-type would exist on Gen 1, it could burn a Pok\u00E9mon.\r\n\t\t\t\t\t\tif (!(secondary.status && ['par', 'brn', 'frz'].includes(secondary.status) && target.hasType(move.type))) {\r\n\t\t\t\t\t\t\tif (secondary.chance === undefined) {\r\n\t\t\t\t\t\t\t\tthis.moveHit(target, pokemon, move, secondary, true, isSelf);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tlet secondaryChance = Math.ceil(secondary.chance * 256 / 100);\r\n\t\t\t\t\t\t\t\t// If the secondary effect is confusion, the numerator should be decreased by 1 (10% = 25/256 not 26/256).\r\n\t\t\t\t\t\t\t\tif (secondary?.volatileStatus === 'confusion') secondaryChance--;\r\n\t\t\t\t\t\t\t\tif (this.battle.randomChance(secondaryChance, 256)) {\r\n\t\t\t\t\t\t\t\t\tthis.moveHit(target, pokemon, move, secondary, true, isSelf);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (move.selfSwitch && pokemon.hp) {\r\n\t\t\t\tpokemon.switchFlag = move.selfSwitch === true ? true : this.dex.toID(move.selfSwitch);\r\n\t\t\t}\r\n\r\n\t\t\treturn damage;\r\n\t\t},\r\n\t\t// This calculates the damage pokemon does to target with move.\r\n\t\tgetDamage(source, target, move, suppressMessages) {\r\n\t\t\t// First of all, we get the move.\r\n\t\t\tif (typeof move === 'string') {\r\n\t\t\t\tmove = this.battle.dex.getActiveMove(move);\r\n\t\t\t} else if (typeof move === 'number') {\r\n\t\t\t\tmove = {\r\n\t\t\t\t\tbasePower: move,\r\n\t\t\t\t\ttype: '???',\r\n\t\t\t\t\tcategory: 'Physical',\r\n\t\t\t\t\twillCrit: false,\r\n\t\t\t\t\tflags: {},\r\n\t\t\t\t} as ActiveMove;\r\n\t\t\t}\r\n\r\n\t\t\t// Let's see if the target is immune to the move.\r\n\t\t\tif (!move.ignoreImmunity || (move.ignoreImmunity !== true && !move.ignoreImmunity[move.type])) {\r\n\t\t\t\tif (!target.runImmunity(move.type, true)) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Is it an OHKO move?\r\n\t\t\tif (move.ohko) {\r\n\t\t\t\treturn 65535;\r\n\t\t\t}\r\n\r\n\t\t\t// We edit the damage through move's damage callback if necessary.\r\n\t\t\tif (move.damageCallback) {\r\n\t\t\t\treturn move.damageCallback.call(this.battle, source, target);\r\n\t\t\t}\r\n\r\n\t\t\t// We take damage from damage=level moves (seismic toss).\r\n\t\t\tif (move.damage === 'level') {\r\n\t\t\t\treturn source.level;\r\n\t\t\t}\r\n\r\n\t\t\t// If there's a fix move damage, we return that.\r\n\t\t\tif (move.damage || move.damage === 0) {\r\n\t\t\t\treturn move.damage;\r\n\t\t\t}\r\n\r\n\t\t\t// If it's the first hit on a Normal-type partially trap move, it hits Ghosts anyways but damage is 0.\r\n\t\t\tif (move.volatileStatus === 'partiallytrapped' && move.type === 'Normal' && target.hasType('Ghost')) {\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\r\n\t\t\t// Let's check if we are in middle of a partial trap sequence to return the previous damage.\r\n\t\t\tif (source.volatiles['partialtrappinglock'] && (target === source.volatiles['partialtrappinglock'].locked)) {\r\n\t\t\t\treturn source.volatiles['partialtrappinglock'].damage;\r\n\t\t\t}\r\n\r\n\t\t\t// We check the category and typing to calculate later on the damage.\r\n\t\t\tif (!move.category) move.category = 'Physical';\r\n\t\t\t// '???' is typeless damage: used for Struggle and Confusion etc\r\n\t\t\tif (!move.type) move.type = '???';\r\n\t\t\tconst type = move.type;\r\n\r\n\t\t\t// We get the base power and apply basePowerCallback if necessary.\r\n\t\t\tlet basePower: number | false | null = move.basePower;\r\n\t\t\tif (move.basePowerCallback) {\r\n\t\t\t\tbasePower = move.basePowerCallback.call(this.battle, source, target, move);\r\n\t\t\t}\r\n\t\t\tif (!basePower) {\r\n\t\t\t\treturn basePower === 0 ? undefined : basePower;\r\n\t\t\t}\r\n\t\t\tbasePower = this.battle.clampIntRange(basePower, 1);\r\n\r\n\t\t\t// Checking for the move's Critical Hit possibility. We check if it's a 100% crit move, otherwise we calculate the chance.\r\n\t\t\tlet isCrit = move.willCrit || false;\r\n\t\t\tif (!isCrit) {\r\n\t\t\t\t// In gen 1, the critical chance is based on speed.\r\n\t\t\t\t// First, we get the base speed, divide it by 2 and floor it. This is our current crit chance.\r\n\t\t\t\tlet critChance = Math.floor(this.dex.species.get(source.set.species).baseStats['spe'] / 2);\r\n\r\n\t\t\t\t// Now we check for focus energy volatile.\r\n\t\t\t\tif (source.volatiles['focusenergy']) {\r\n\t\t\t\t\t// If it exists, crit chance is divided by 2 again and floored.\r\n\t\t\t\t\tcritChance = Math.floor(critChance / 2);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Normally, without focus energy, crit chance is multiplied by 2 and capped at 255 here.\r\n\t\t\t\t\tcritChance = this.battle.clampIntRange(critChance * 2, 1, 255);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Now we check for the move's critical hit ratio.\r\n\t\t\t\tif (move.critRatio === 1) {\r\n\t\t\t\t\t// Normal hit ratio, we divide the crit chance by 2 and floor the result again.\r\n\t\t\t\t\tcritChance = Math.floor(critChance / 2);\r\n\t\t\t\t} else if (move.critRatio === 2) {\r\n\t\t\t\t\t// High crit ratio, we multiply the result so far by 4 and cap it at 255.\r\n\t\t\t\t\tcritChance = this.battle.clampIntRange(critChance * 4, 1, 255);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Last, we check deppending on ratio if the move critical hits or not.\r\n\t\t\t\t// We compare our critical hit chance against a random number between 0 and 255.\r\n\t\t\t\t// If the random number is lower, we get a critical hit. This means there is always a 1/255 chance of not hitting critically.\r\n\t\t\t\tif (critChance > 0) {\r\n\t\t\t\t\tisCrit = this.battle.randomChance(critChance, 256);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (isCrit) target.getMoveHitData(move).crit = true;\r\n\r\n\t\t\t// Happens after crit calculation.\r\n\t\t\tif (basePower) {\r\n\t\t\t\tbasePower = this.battle.runEvent('BasePower', source, target, move, basePower);\r\n\t\t\t\tif (basePower && move.basePowerModifier) {\r\n\t\t\t\t\tbasePower *= move.basePowerModifier;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!basePower) return 0;\r\n\t\t\tbasePower = this.battle.clampIntRange(basePower, 1);\r\n\r\n\t\t\t// We now check attacker's and defender's stats.\r\n\t\t\tlet level = source.level;\r\n\t\t\tconst attacker = move.overrideOffensivePokemon === 'target' ? target : source;\r\n\t\t\tconst defender = move.overrideDefensivePokemon === 'source' ? source : target;\r\n\r\n\t\t\tconst isPhysical = move.category === 'Physical';\r\n\t\t\tconst atkType: StatIDExceptHP = move.overrideOffensiveStat || (isPhysical ? 'atk' : 'spa');\r\n\t\t\tconst defType: StatIDExceptHP = move.overrideDefensiveStat || (isPhysical ? 'def' : 'spd');\r\n\r\n\t\t\tlet attack = attacker.getStat(atkType);\r\n\t\t\tlet defense = defender.getStat(defType);\r\n\r\n\t\t\t// In gen 1, screen effect is applied here.\r\n\t\t\tif ((defType === 'def' && defender.volatiles['reflect']) || (defType === 'spd' && defender.volatiles['lightscreen'])) {\r\n\t\t\t\tthis.battle.debug('Screen doubling (Sp)Def');\r\n\t\t\t\tdefense *= 2;\r\n\t\t\t}\r\n\r\n\t\t\t// In the event of a critical hit, the offense and defense changes are ignored.\r\n\t\t\t// This includes both boosts and screens.\r\n\t\t\t// Also, level is doubled in damage calculation.\r\n\t\t\tif (isCrit) {\r\n\t\t\t\tmove.ignoreOffensive = true;\r\n\t\t\t\tmove.ignoreDefensive = true;\r\n\t\t\t\tlevel *= 2;\r\n\t\t\t\tif (!suppressMessages) this.battle.add('-crit', target);\r\n\t\t\t}\r\n\r\n\t\t\tif (move.ignoreOffensive) {\r\n\t\t\t\tthis.battle.debug('Negating (sp)atk boost/penalty.');\r\n\t\t\t\tattack = attacker.getStat(atkType, true);\r\n\t\t\t}\r\n\r\n\t\t\tif (move.ignoreDefensive) {\r\n\t\t\t\tthis.battle.debug('Negating (sp)def boost/penalty.');\r\n\t\t\t\t// No screens\r\n\t\t\t\tdefense = target.getStat(defType, true);\r\n\t\t\t}\r\n\r\n\t\t\t// When either attack or defense are higher than 256, both are divided by 4.\r\n\t\t\t// If that's still over 256, it rolls over (%256), which is what causes rollover bugs.\r\n\t\t\tif (attack >= 256 || defense >= 256) {\r\n\t\t\t\tif (attack >= 1024 || defense >= 1024) {\r\n\t\t\t\t\tthis.battle.hint(\"In Gen 1, a stat will roll over to a small number if it is larger than 1024.\");\r\n\t\t\t\t}\r\n\t\t\t\tattack = this.battle.clampIntRange(Math.floor(attack / 4) % 256, 1);\r\n\t\t\t\t// Defense isn't checked on the cartridge, but we don't want those / 0 bugs on the sim.\r\n\t\t\t\tdefense = Math.floor(defense / 4) % 256;\r\n\t\t\t\tif (defense === 0) {\r\n\t\t\t\t\tthis.battle.hint('Pokemon Showdown avoids division by zero by rounding defense up to 1. ' +\r\n\t\t\t\t\t\t'In game, the battle would have crashed.');\r\n\t\t\t\t\tdefense = 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Self destruct moves halve defense at this point.\r\n\t\t\tif (move.selfdestruct && defType === 'def') {\r\n\t\t\t\tdefense = this.battle.clampIntRange(Math.floor(defense / 2), 1);\r\n\t\t\t}\r\n\r\n\t\t\t// Let's go with the calculation now that we have what we need.\r\n\t\t\t// We do it step by step just like the game does.\r\n\t\t\tlet damage = level * 2;\r\n\t\t\tdamage = Math.floor(damage / 5);\r\n\t\t\tdamage += 2;\r\n\t\t\tdamage *= basePower;\r\n\t\t\tdamage *= attack;\r\n\t\t\tdamage = Math.floor(damage / defense);\r\n\t\t\tdamage = this.battle.clampIntRange(Math.floor(damage / 50), 0, 997);\r\n\t\t\tdamage += 2;\r\n\r\n\t\t\t// STAB damage bonus, the \"???\" type never gets STAB\r\n\t\t\tif (type !== '???' && source.hasType(type)) {\r\n\t\t\t\tdamage += Math.floor(damage / 2);\r\n\t\t\t}\r\n\r\n\t\t\t// Type effectiveness.\r\n\t\t\t// In Gen 1, type effectiveness is applied against each of the target's types.\r\n\t\t\tfor (const targetType of target.types) {\r\n\t\t\t\tconst typeMod = this.battle.dex.getEffectiveness(type, targetType);\r\n\t\t\t\tif (typeMod > 0) {\r\n\t\t\t\t\t// Super effective against targetType\r\n\t\t\t\t\tdamage *= 20;\r\n\t\t\t\t\tdamage = Math.floor(damage / 10);\r\n\t\t\t\t}\r\n\t\t\t\tif (typeMod < 0) {\r\n\t\t\t\t\t// Not very effective against targetType\r\n\t\t\t\t\tdamage *= 5;\r\n\t\t\t\t\tdamage = Math.floor(damage / 10);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tconst totalTypeMod = target.runEffectiveness(move);\r\n\t\t\tif (totalTypeMod > 0) {\r\n\t\t\t\tif (!suppressMessages) this.battle.add('-supereffective', target);\r\n\t\t\t}\r\n\t\t\tif (totalTypeMod < 0) {\r\n\t\t\t\tif (!suppressMessages) this.battle.add('-resisted', target);\r\n\t\t\t}\r\n\r\n\t\t\t// If damage becomes 0, the move is made to miss.\r\n\t\t\t// This occurs when damage was either 2 or 3 prior to applying STAB/Type matchup, and target is 4x resistant to the move.\r\n\t\t\tif (damage === 0) return damage;\r\n\r\n\t\t\t// Apply random factor if damage is greater than 1\r\n\t\t\tif (damage > 1) {\r\n\t\t\t\tdamage *= this.battle.random(217, 256);\r\n\t\t\t\tdamage = Math.floor(damage / 255);\r\n\t\t\t}\r\n\r\n\t\t\t// And we are done.\r\n\t\t\treturn Math.floor(damage);\r\n\t\t},\r\n\t},\r\n\t// deals with Pok\u00E9mon stat boosting.\r\n\tboost(boost, target, source = null, effect = null) {\r\n\t\tif (this.event) {\r\n\t\t\tif (!target) target = this.event.target;\r\n\t\t\tif (!source) source = this.event.source;\r\n\t\t\tif (!effect) effect = this.effect;\r\n\t\t}\r\n\t\tif (typeof effect === 'string') effect = this.dex.conditions.get(effect);\r\n\t\tif (!target?.hp) return 0;\r\n\t\tlet success = null;\r\n\t\tboost = this.runEvent('TryBoost', target, source, effect, {...boost});\r\n\t\tlet i: BoostID;\r\n\t\tfor (i in boost) {\r\n\t\t\tconst currentBoost: SparseBoostsTable = {};\r\n\t\t\tcurrentBoost[i] = boost[i];\r\n\t\t\tif (boost[i] !== 0) {\r\n\t\t\t\tconst boostResult = target.boostBy(currentBoost);\r\n\t\t\t\tif (boostResult) {\r\n\t\t\t\t\tsuccess = true;\r\n\t\t\t\t\tlet msg = '-boost';\r\n\t\t\t\t\tif (boost[i]! < 0) {\r\n\t\t\t\t\t\tmsg = '-unboost';\r\n\t\t\t\t\t\tboost[i] = -boost[i]!;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!effect || effect.effectType === 'Move') {\r\n\t\t\t\t\t\tthis.add(msg, target, i, boost[i]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.add(msg, target, i, boost[i], '[from] ' + effect.fullname);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.runEvent('AfterEachBoost', target, source, effect, currentBoost);\r\n\t\t\t\t}\r\n\t\t\t\t// Tried to boost at 999 or unboost at 1. This does not count as a success: par/brn effects are not applied afterwards.\r\n\t\t\t\tif (boostResult === 0) {\r\n\t\t\t\t\tlet msg = '-boost';\r\n\t\t\t\t\tlet secondmsg = '-unboost';\r\n\t\t\t\t\tif (boost[i]! < 0) {\r\n\t\t\t\t\t\tmsg = '-unboost';\r\n\t\t\t\t\t\tsecondmsg = '-boost';\r\n\t\t\t\t\t\tboost[i] = -boost[i]!;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!effect || effect.effectType === 'Move') {\r\n\t\t\t\t\t\tthis.add(msg, target, i, boost[i]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.add(msg, target, i, boost[i], '[from] ' + effect.fullname);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.add(secondmsg, target, i, 1);\r\n\t\t\t\t\tif (msg === '-boost') {\r\n\t\t\t\t\t\tthis.hint(`In Gen 1, boosting a stat at 999 will apply a -1 drop afterwards, and the stat remains at 999.`, true);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.hint(`In Gen 1, dropping a stat at 1 will apply a +1 boost afterwards, and the stat remains at 1.`, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.runEvent('AfterEachBoost', target, source, effect, currentBoost);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.runEvent('AfterBoost', target, source, effect, boost);\r\n\t\treturn success;\r\n\t},\r\n};\r\n"],
  "mappings": "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",
  "names": []
}
